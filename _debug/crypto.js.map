{"version":3,"file":"crypto.js","sourceRoot":"","sources":["crypto.ts"],"names":["getHash","getSign","getProvider","loadProvider","setProvider","callOrNoop","bindOrUndefined","HasherWrapper","HasherWrapper.constructor","HasherWrapper.abort","HasherWrapper.close","HasherWrapper.start","HasherWrapper.write","SignerWrapper","SignerWrapper.constructor","SignerWrapper.abort","SignerWrapper.close","SignerWrapper.start","SignerWrapper.write"],"mappings":"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","sourcesContent":["/**\n * crypto\n *\n * Architecture\n * ------------\n *\n * The crypto API has two main functions: `getHash` and `getSign`. These functions return functions implementing the\n * HashFunction and SignFunction interfaces, respectively. HashFunctions and SignFunctions are what user code calls to\n * hash or sign data.\n *\n * Actual implementations are supplied by providers such as `providers/node.ts`. A provider is just a module exporting\n * the two API functions `getHash` and `getSign`. Since each provider implements the public API, they can be used\n * directly, although this should not generally be necessary.\n *\n * When user code calls this module's `getHash` function, the function immediately starts loading a provider and returns\n * a wrapper function implementing the HashFunction API. The wrapper will defer all calls until the provider loads. Once\n * the provider is loaded, the wrapper calls `getHash` on the provider to obtain a real HashFunction instance and\n * resolves any outstanding calls. Future calls on the wrapper are passed directly to the created HashFunction instance.\n *\n * When the HashFunction wrapper's `create` method is called, it returns a wrapped Hasher instance. Like the\n * HashFunction wrapper, the Hasher wrapper will defer calls until a provider is loaded and a real Hasher implementation\n * has been created, at which point all future calls to methods on the wrapper are passed directly to the real Hasher.\n *\n * The current provider may be requested with the `getProvider` function. Since the initial provider is loaded\n * asynchronously, this function returns a Promise<CryptoProvider>. The provider may be set using the `setProvider`\n * function, which accepts a CryptoProvider.\n */\n\nimport { Codec, ByteBuffer } from 'dojo-core/encoding';\nimport Promise from 'dojo-core/Promise';\nimport { Sink } from 'dojo-core/streams/WritableStream';\nimport has from './has';\n\ndeclare const define: { amd: any };\ndeclare const require: Function;\n\nexport type Data = string | ByteBuffer;\n\n/**\n * Supported hash algorithms \n */\nconst HASH_ALGORITHMS = {\n\tmd5: true,\n\tsha1: true,\n\tsha256: true\n}\n\n/**\n * Supported signing algorithms \n */\nconst SIGN_ALGORITHMS = {\n\thmac: true\n}\n\n/**\n * An interface describing a cryptographic provider.\n */\nexport interface CryptoProvider {\n\tgetHash(algorithm: string): HashFunction;\n\tgetSign(algorithm: string): SignFunction;\n}\n\n/**\n * A function that can hash a chunk of data.\n */\nexport interface HashFunction {\n\t(data: ByteBuffer): Promise<ByteBuffer>;\n\t(data: string, codec?: Codec): Promise<ByteBuffer>;\n\tcreate<T extends Data>(codec?: Codec): Hasher<T>;\n\talgorithm: string;\n}\n\n/**\n * A signing function.\n */\nexport interface SignFunction {\n\t(key: Key, data: ByteBuffer): Promise<ByteBuffer>;\n\t(key: Key, data: string, codec?: Codec): Promise<ByteBuffer>;\n\tcreate<T extends Data>(key: Key, codec?: Codec): Signer<T>;\n\talgorithm: string;\n}\n\n/**\n * The current provider. Providers supply concrete implementations of the API described here. Users should not typically\n * need to access providers directly.\n */\nlet provider: CryptoProvider;\nlet providerPromise: Promise<CryptoProvider>;\n\n/**\n * Gets the HashFunction for a particular algorithm. The algorithm is specified as a string for simplicity and\n * extensibility.\n */\nexport function getHash(algorithm: string): HashFunction {\n\t// If a provider has been loaded, defer to its getHash\n\tif (provider) {\n\t\treturn provider.getHash(algorithm);\n\t}\n\n\t// Before a provider has been loaded, check whether the requested algorithm is one of the standard set. After a\n\t// provider is loaded, it will handle algorithm verification itself.\n\tif (!(algorithm in HASH_ALGORITHMS)) {\n\t\tthrow new Error('invalid algorithm; available algorithms are [ \\'' +\n\t\t\tObject.keys(HASH_ALGORITHMS).join('\\', \\'') + '\\' ]');\n\t}\n\n\tlet realHash: HashFunction;\n\tconst hashPromise = new Promise<HashFunction>(function (resolve, reject) {\n\t\tgetProvider().then(function (provider) {\n\t\t\trealHash = provider.getHash(algorithm);\n\t\t\tresolve(realHash);\n\t\t}).catch(function (error) {\n\t\t\treject(error);\n\t\t});\n\t});\n\n\t// Return a wrapper that will defer calls to the hash until a provider has been loaded.\n\tconst hashFunction = <HashFunction> function (data: Data, codec?: Codec): Promise<ByteBuffer> {\n\t\tif (realHash) {\n\t\t\treturn realHash(<any> data, codec);\n\t\t}\n\t\treturn hashPromise.then<ByteBuffer>(function (hash) {\n\t\t\treturn hash(<any> data, codec);\n\t\t});\n\t};\n\n\t// Return a wrapper class that will defer calls until a provider has been loaded and an actual Hasher instance has\n\t// been created.\n\thashFunction.create = function<T extends Data> (codec?: Codec): Hasher<T> {\n\t\tif (realHash) {\n\t\t\thashFunction.create = realHash.create.bind(realHash);\n\t\t\treturn realHash.create(codec);\n\t\t}\n\t\treturn new HasherWrapper(hashPromise, codec);\n\t};\n\n\treturn hashFunction;\n}\n\n/**\n * Gets the SignFunction for a particular algorithm. The algorithm is specified as a string for simplicity and\n * extensibility.\n */\nexport function getSign(algorithm: string): SignFunction {\n\t// If a provider has been loaded, defer to its getSign\n\tif (provider) {\n\t\treturn provider.getSign(algorithm);\n\t}\n\n\t// Before a provider has been loaded, check whether the requested algorithm is one of the standard set. After a\n\t// provider is loaded, it will handle algorithm verification itself.\n\tif (!(algorithm in SIGN_ALGORITHMS)) {\n\t\tthrow new Error('invalid algorithm; available algorithms are [ \\'' +\n\t\t\tObject.keys(SIGN_ALGORITHMS).join('\\', \\'') + '\\' ]');\n\t}\n\n\tlet realSign: SignFunction;\n\tconst signPromise = new Promise<SignFunction>(function (resolve, reject) {\n\t\tgetProvider().then(function (provider) {\n\t\t\trealSign = provider.getSign(algorithm);\n\t\t\tresolve(realSign);\n\t\t}).catch(function (error) {\n\t\t\treject(error);\n\t\t});\n\t});\n\n\t// Return a wrapper that will defer calls to the sign function until a provider has been loaded.\n\tconst signFunction = <SignFunction> function (key: Key, data: Data, codec?: Codec): Promise<ByteBuffer> {\n\t\tif (realSign) {\n\t\t\treturn realSign(key, <any> data, codec);\n\t\t}\n\t\treturn signPromise.then<ByteBuffer>(function (sign) {\n\t\t\treturn sign(key, <any> data, codec);\n\t\t});\n\t};\n\n\t// Return a wrapper class that will defer calls until a provider has been loaded and an actual SignFunction instance\n\t// has been created.\n\tsignFunction.create = function<T extends Data> (key: Key, codec?: Codec): Signer<T> {\n\t\treturn new SignerWrapper(signPromise, key, codec);\n\t};\n\n\treturn signFunction;\n}\n\n/**\n * Returns a promise that resolves to the current provider object.\n */\nfunction getProvider(): Promise<CryptoProvider> {\n\tif (provider) {\n\t\treturn Promise.resolve(provider);\n\t}\n\n\tif (providerPromise) {\n\t\treturn providerPromise;\n\t}\n\n\tproviderPromise = new Promise(function (resolve, reject) {\n\t\t// Load a platform-specific default provider.\n\t\tif (typeof define === 'function' && define.amd) {\n\t\t\tfunction loadProvider(mid: string) {\n\t\t\t\trequire([ mid ], function (_provider: CryptoProvider) {\n\t\t\t\t\t// Don't overwrite a provider if one has already been set\n\t\t\t\t\tif (!provider) {\n\t\t\t\t\t\tprovider = _provider;\n\t\t\t\t\t}\n\t\t\t\t\tresolve(provider);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (has('host-node')) {\n\t\t\t\tloadProvider('./providers/node');\n\t\t\t}\n\t\t\telse if (has('webcrypto')) {\n\t\t\t\tloadProvider('./providers/webcrypto');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tloadProvider('./providers/script');\n\t\t\t}\n\t\t}\n\t\telse if (has('host-node')) {\n\t\t\tprovider = require('./providers/node');\n\t\t\tresolve(provider);\n\t\t}\n\t\telse {\n\t\t\treject(new Error('Unknown environment or loader'));\n\t\t}\n\t});\n\n\treturn providerPromise;\n}\n\n/**\n * Sets the implementation provider.\n *\n * The provider may either be a loaded provider or a Promise that will resolve to a provider.\n */\nexport function setProvider(_provider: CryptoProvider | Promise<CryptoProvider>): void {\n\tproviderPromise = provider = null;\n\n\tif (_provider) {\n\t\tif ((<any> _provider).then) {\n\t\t\tproviderPromise = <Promise<CryptoProvider>> _provider;\n\t\t}\n\t\telse if ((<any> _provider).getHash) {\n\t\t\tprovider = <CryptoProvider> _provider;\n\t\t}\n\t}\n}\n\n/**\n * An object for hashing a data stream.\n */\nexport interface Hasher<T extends Data> extends Sink<T> {\n\tdigest: Promise<ByteBuffer>;  // read only\n}\n\n/**\n * Call a method that returns a promise, or return a resolved Promise if the method doesn't exist on the object\n */\nfunction callOrNoop(object: any, methodName: string, ...args: any[]): Promise<any> {\n\tconst method: Function = object[methodName];\n\tif (!method) {\n\t\treturn Promise.resolve()\n\t}\n\treturn method.apply(object, args);\n}\n\nfunction bindOrUndefined(object: any, methodName: string): any {\n\tconst method: Function = object[methodName];\n\tif (method) {\n\t\treturn method.bind(object);\n\t}\n}\n\n/**\n * A wrapper around a Promise<HashFunction> that will defer calls while a provider is asynchronously loaded.\n */\nclass HasherWrapper<T extends Data> implements Hasher<T> {\n\tconstructor(hashPromise: Promise<HashFunction>, codec: Codec) {\n\t\tObject.defineProperty(this, '_promise', {\n\t\t\tvalue: new Promise((resolve, reject) => {\n\t\t\t\thashPromise.then(\n\t\t\t\t\t(hashFunction) => {\n\t\t\t\t\t\t// When the hash function resolves, create a Hasher and replace this object's methods with\n\t\t\t\t\t\t// pointers to the corresponding methods on the Hasher.\n\t\t\t\t\t\tconst hasher = hashFunction.create(codec);\n\t\t\t\t\t\tthis.abort = bindOrUndefined(hasher, 'abort');\n\t\t\t\t\t\tthis.close = bindOrUndefined(hasher, 'close');\n\t\t\t\t\t\tthis.start = bindOrUndefined(hasher, 'start');\n\t\t\t\t\t\tthis.write = bindOrUndefined(hasher, 'write');\n\t\t\t\t\t\tresolve(hasher);\n\t\t\t\t\t},\n\t\t\t\t\tfunction (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t})\n\t\t});\n\n\t\tObject.defineProperty(this, 'digest', {\n\t\t\tenumerable: true,\n\t\t\tvalue: new Promise((resolve, reject) => {\n\t\t\t\tthis._promise.then(\n\t\t\t\t\tfunction (hasher) {\n\t\t\t\t\t\tresolve(hasher.digest);\n\t\t\t\t\t},\n\t\t\t\t\tfunction (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t})\n\t\t});\n\t}\n\n\tprivate _promise: Promise<Hasher<T>>;\n\n\tdigest: Promise<ByteBuffer>;\n\n\t// Sink methods; the provider may or may not implement these, so call them with callOrNoop\n\n\tabort(reason?: Error): Promise<void> {\n\t\treturn this._promise.then(function (hasher) {\n\t\t\treturn callOrNoop(hasher, 'abort', reason);\n\t\t});\n\t}\n\n\tclose(): Promise<void> {\n\t\treturn this._promise.then(function (hasher) {\n\t\t\treturn callOrNoop(hasher, 'close');\n\t\t});\n\t}\n\n\tstart(error: (error: Error) => void): Promise<void> {\n\t\treturn this._promise.then(function (hasher) {\n\t\t\treturn callOrNoop(hasher, 'start', error);\n\t\t});\n\t}\n\n\twrite(chunk: T): Promise<void> {\n\t\treturn this._promise.then(function (hasher) {\n\t\t\treturn callOrNoop(hasher, 'write', chunk);\n\t\t});\n\t}\n}\n\n/**\n * A cryptographic key.\n */\nexport interface Key {\n\talgorithm: string,\n\tdata: Data\n}\n\n/**\n * An object for signing a data stream.\n */\nexport interface Signer<T extends Data> extends Sink<T> {\n\tsignature: Promise<ByteBuffer>;  // read only\n}\n\n/**\n * A wrapper around a Promise<SignFunction> that will defer calls while a provider is asynchronously loaded.\n */\nclass SignerWrapper<T extends Data> implements Signer<T> {\n\tconstructor(signPromise: Promise<SignFunction>, key: Key, codec: Codec) {\n\t\tObject.defineProperty(this, '_promise', {\n\t\t\tvalue: new Promise((resolve, reject) => {\n\t\t\t\tsignPromise.then((signFunction) => {\n\t\t\t\t\t// When the sign function resolves, create a Signer and replace this object's methods with\n\t\t\t\t\t// pointers to the corresponding methods on the Signer.\n\t\t\t\t\tconst signer = signFunction.create(key, codec);\n\t\t\t\t\tthis.abort = bindOrUndefined(signer, 'abort');\n\t\t\t\t\tthis.close = bindOrUndefined(signer, 'close');\n\t\t\t\t\tthis.start = bindOrUndefined(signer, 'start');\n\t\t\t\t\tthis.write = bindOrUndefined(signer, 'write');\n\t\t\t\t\tresolve(signer);\n\t\t\t\t}).catch(function (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t});\n\t\t\t})\n\t\t});\n\n\t\tObject.defineProperty(this, 'signature', {\n\t\t\tvalue: new Promise((resolve, reject) => {\n\t\t\t\tthis._promise.then(\n\t\t\t\t\tfunction (signer) {\n\t\t\t\t\t\tresolve(signer.signature);\n\t\t\t\t\t},\n\t\t\t\t\tfunction (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t})\n\t\t});\n\t}\n\n\tprivate _promise: Promise<Signer<T>>;\n\n\tsignature: Promise<ByteBuffer>;\n\n\t// Sink methods; the provider may or may not implement these, so call them with callOrNoop\n\n\tabort(reason?: Error): Promise<void> {\n\t\treturn this._promise.then(function (signer) {\n\t\t\treturn callOrNoop(signer, 'abort', reason);\n\t\t});\n\t}\n\n\tclose(): Promise<void> {\n\t\treturn this._promise.then(function (signer) {\n\t\t\treturn callOrNoop(signer, 'close');\n\t\t});\n\t}\n\n\tstart(error: (error: Error) => void): Promise<void> {\n\t\treturn this._promise.then(function (signer) {\n\t\t\treturn callOrNoop(signer, 'start', error);\n\t\t});\n\t}\n\n\twrite(chunk: T): Promise<void> {\n\t\treturn this._promise.then(function (signer) {\n\t\t\treturn callOrNoop(signer, 'write', chunk);\n\t\t});\n\t}\n}\n"]}