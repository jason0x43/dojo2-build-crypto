{"version":3,"file":"hash.js","sourceRoot":"","sources":["providers/node/hash.ts"],"names":["nodeHash","NodeHasher","NodeHasher.constructor","NodeHasher.abort","NodeHasher.close","NodeHasher.write","getHash"],"mappings":"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","sourcesContent":["import * as crypto from 'crypto';\nimport Promise, { State } from 'dojo-core/Promise';\nimport { ByteBuffer, Codec, utf8 } from 'dojo-core/encoding';\nimport { Data, Hasher, HashFunction } from '../../crypto';\nimport { getEncodingName } from './util';\n\n/**\n * A mapping of crypto algorithm names to their node equivalents\n */\nconst ALGORITHMS = {\n\tmd5: 'md5',\n\tsha1: 'sha1',\n\tsha256: 'sha256'\n};\n\n/**\n * Hashes a chunk of data.\n */\nfunction nodeHash(algorithm: string, data: Data, codec: Codec): Promise<ByteBuffer> {\n\tconst hash = crypto.createHash(algorithm);\n\tconst encoding = getEncodingName(codec);\n\thash.update(data, encoding);\n\treturn Promise.resolve(hash.digest());\n}\n\n// Cache a resolved Promise to return from the stream methods.\nconst resolvedPromise = Promise.resolve();\n\n/**\n * An object that can be used to hash a stream of data.\n */\nclass NodeHasher<T extends Data> implements Hasher<T> {\n\tconstructor(algorithm: string, encoding: string) {\n\t\tObject.defineProperty(this, '_hash', {\n\t\t\tconfigurable: true,\n\t\t\tvalue: crypto.createHash(algorithm)\n\t\t});\n\t\tObject.defineProperty(this, '_encoding', { value: encoding });\n\t\tObject.defineProperty(this, 'digest', {\n\t\t\tenumerable: true,\n\t\t\tvalue: new Promise((resolve, reject) => {\n\t\t\t\tObject.defineProperty(this, '_resolve', { value: resolve });\n\t\t\t\tObject.defineProperty(this, '_reject', { value: reject });\n\t\t\t})\n\t\t});\n\t}\n\n\tprivate _hash: crypto.Hash;\n\tprivate _encoding: string;\n\tprivate _resolve: (value: any) => void;\n\tprivate _reject: (reason: Error) => void;\n\n\tdigest: Promise<ByteBuffer>;\n\n\tabort(reason?: Error): Promise<any> {\n\t\tif (this.digest.state !== State.Pending) {\n\t\t\treturn this.digest;\n\t\t}\n\n\t\t// Release the reference to the Hash instance and reject the digest\n\t\tObject.defineProperty(this, '_hash', { value: undefined });\n\t\tthis._reject(reason);\n\t\treturn resolvedPromise;\n\t}\n\n\tclose(): Promise<any> {\n\t\tif (this.digest.state !== State.Pending) {\n\t\t\treturn this.digest;\n\t\t}\n\n\t\tthis._resolve(this._hash.digest());\n\t\t// Release the reference to the Hash instance\n\t\tObject.defineProperty(this, '_hash', { value: undefined });\n\t\treturn resolvedPromise;\n\t}\n\n\twrite(chunk: T): Promise<any> {\n\t\tif (this.digest.state !== State.Pending) {\n\t\t\treturn this.digest;\n\t\t}\n\n\t\tlet _chunk: T | Buffer = chunk;\n\t\t// Node can't work with Arrays, so convert them to Buffers\n\t\t// The node typing for Sign#update is incorrect -- it shares the same signature as Hash#update\n\t\ttry {\n\t\t\tif (Array.isArray(chunk)) {\n\t\t\t\tthis._hash.update(new Buffer(<any> chunk, this._encoding));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis._hash.update(chunk, this._encoding);\n\t\t\t}\n\t\t\treturn resolvedPromise;\n\t\t}\n\t\tcatch (error) {\n\t\t\tthis._reject(error);\n\t\t\treturn this.digest;\n\t\t}\n\t}\n}\n\nexport default function getHash(algorithm: string): HashFunction {\n\tconst hasher = <HashFunction> function (data: Data, codec: Codec = utf8): Promise<ByteBuffer> {\n\t\treturn nodeHash(algorithm, data, codec);\n\t};\n\thasher.create = function<T extends Data> (codec: Codec = utf8): Hasher<T> {\n\t\treturn new NodeHasher<T>(algorithm, getEncodingName(codec));\n\t};\n\thasher.algorithm = algorithm;\n\n\treturn hasher;\n}\n"]}