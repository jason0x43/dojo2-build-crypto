{"version":3,"file":"sign.js","sourceRoot":"","sources":["providers/node/sign.ts"],"names":["sign","NodeSigner","NodeSigner.constructor","NodeSigner.abort","NodeSigner.close","NodeSigner.write","getSign"],"mappings":";;;;;;;;IAAA,IAAY,MAAM,WAAM,QAAQ,CAAC,CAAA;IACjC,wBAA+B,mBAAmB,CAAC,CAAA;IACnD,yBAAwC,oBAAoB,CAAC,CAAA;IAE7D,qBAAgC,QAAQ,CAAC,CAAA;IAKzC,AAHA;;OAEG;QACG,UAAU,GAAG;QAClB,IAAI,EAAE,MAAM;KACZ,CAAC;IAEF,IAAM,eAAe,GAAG,iBAAO,CAAC,OAAO,EAAE,CAAC;IAK1C,AAHA;;OAEG;kBACW,SAAiB,EAAE,GAAQ,EAAE,IAAU,EAAE,KAAY;QAClEA,IAAMA,aAAaA,GAAGA,GAAGA,CAACA,SAASA,CAACA;QACpCA,IAAMA,IAAIA,GAAGA,MAAMA,CAACA,UAAUA,CAACA,aAAaA,EAAWA,GAAGA,CAACA,IAAIA,CAACA,CAACA;QACjEA,IAAMA,QAAQA,GAAGA,sBAAeA,CAACA,KAAKA,CAACA,CAACA;QAGxCA,AADAA,6FAA6FA;QAC7FA,EAAEA,CAACA,CAACA,KAAKA,CAACA,OAAOA,CAACA,IAAIA,CAACA,CAACA,CAACA,CAACA;YACzBA,IAAIA,GAAGA,IAAIA,MAAMA,CAAYA,IAAIA,CAACA,CAACA;QACpCA,CAACA;QAEDA,IAAIA,CAACA,MAAMA,CAACA,IAAIA,EAAEA,QAAQA,CAACA,CAACA;QAC5BA,MAAMA,CAACA,iBAAOA,CAACA,OAAOA,CAACA,IAAIA,CAACA,MAAMA,EAAEA,CAACA,CAACA;IACvCA,CAACA;IAKD,AAHA;;OAEG;;QAEFC,oBAAYA,SAAiBA,EAAEA,GAAQA,EAAEA,QAAgBA;YAD1DC,iBA8ECA;YA5ECA,MAAMA,CAACA,cAAcA,CAACA,IAAIA,EAAEA,WAAWA,EAAEA;gBACxCA,KAAKA,EAAEA,IAAIA,iBAAOA,CAACA,UAACA,OAAOA,EAAEA,MAAMA;oBAClCA,MAAMA,CAACA,cAAcA,CAACA,KAAIA,EAAEA,UAAUA,EAAEA,EAAEA,KAAKA,EAAEA,OAAOA,EAAEA,CAACA,CAACA;oBAC5DA,MAAMA,CAACA,cAAcA,CAACA,KAAIA,EAAEA,SAASA,EAAEA,EAAEA,KAAKA,EAAEA,MAAMA,EAAEA,CAACA,CAACA;gBAC3DA,CAACA,CAACA;aACFA,CAACA,CAACA;YAEHA,IAAIA,CAACA;gBAEJA,AADAA,6CAA6CA;gBAC7CA,EAAEA,CAACA,CAACA,OAAOA,GAAGA,CAACA,IAAIA,KAAKA,QAAQA,IAAIA,CAACA,CAACA,GAAGA,CAACA,IAAIA,YAAYA,MAAMA,CAACA,CAACA,CAACA,CAACA;oBACnEA,MAAMA,IAAIA,KAAKA,CAACA,8CAA8CA,CAACA,CAACA;gBACjEA,CAACA;gBAEDA,MAAMA,CAACA,cAAcA,CAACA,IAAIA,EAAEA,OAAOA,EAAEA;oBACpCA,YAAYA,EAAEA,IAAIA;oBAClBA,KAAKA,EAAEA,MAAMA,CAACA,UAAUA,CAACA,GAAGA,CAACA,SAASA,EAAWA,GAAGA,CAACA,IAAIA,CAACA;iBAC1DA,CAACA,CAACA;gBACHA,MAAMA,CAACA,cAAcA,CAACA,IAAIA,EAAEA,WAAWA,EAAEA,EAAEA,KAAKA,EAAEA,QAAQA,EAAEA,CAACA,CAACA;YAC/DA,CACAA;YAAAA,KAAKA,CAACA,CAACA,KAAKA,CAACA,CAACA,CAACA;gBACdA,IAAIA,CAACA,OAAOA,CAACA,KAAKA,CAACA,CAACA;YACrBA,CAACA;QACFA,CAACA;QASDD,0BAAKA,GAALA,UAAMA,MAAcA;YACnBE,EAAEA,CAACA,CAACA,IAAIA,CAACA,SAASA,CAACA,KAAKA,KAAKA,eAAKA,CAACA,OAAOA,CAACA,CAACA,CAACA;gBAC5CA,MAAMA,CAACA,IAAIA,CAACA,SAASA,CAACA;YACvBA,CAACA;YAGDA,AADAA,6EAA6EA;YAC7EA,MAAMA,CAACA,cAAcA,CAACA,IAAIA,EAAEA,OAAOA,EAAEA,EAAEA,KAAKA,EAAEA,SAASA,EAAEA,CAACA,CAACA;YAC3DA,IAAIA,CAACA,OAAOA,CAACA,MAAMA,CAACA,CAACA;YACrBA,MAAMA,CAACA,eAAeA,CAACA;QACxBA,CAACA;QAEDF,0BAAKA,GAALA;YACCG,EAAEA,CAACA,CAACA,IAAIA,CAACA,SAASA,CAACA,KAAKA,KAAKA,eAAKA,CAACA,OAAOA,CAACA,CAACA,CAACA;gBAC5CA,MAAMA,CAACA,IAAIA,CAACA,SAASA,CAACA;YACvBA,CAACA;YAEDA,IAAMA,MAAMA,GAAkBA,IAAIA,CAACA,KAAMA,CAACA,MAAMA,EAAEA,CAACA;YAEnDA,AADAA,oDAAoDA;YACpDA,MAAMA,CAACA,cAAcA,CAACA,IAAIA,EAAEA,OAAOA,EAAEA,EAAEA,KAAKA,EAAEA,SAASA,EAAEA,CAACA,CAACA;YAC3DA,IAAIA,CAACA,QAAQA,CAACA,MAAMA,CAACA,CAACA;YACtBA,MAAMA,CAACA,eAAeA,CAACA;QACxBA,CAACA;QAEDH,0BAAKA,GAALA,UAAMA,KAAQA;YACbI,EAAEA,CAACA,CAACA,IAAIA,CAACA,SAASA,CAACA,KAAKA,KAAKA,eAAKA,CAACA,OAAOA,CAACA,CAACA,CAACA;gBAC5CA,MAAMA,CAACA,IAAIA,CAACA,SAASA,CAACA;YACvBA,CAACA;YAEDA,IAAIA,MAAMA,GAAeA,KAAKA,CAACA;YAG/BA,AAFAA,0DAA0DA;YAC1DA,8FAA8FA;gBAC1FA,CAACA;gBACJA,EAAEA,CAACA,CAACA,KAAKA,CAACA,OAAOA,CAACA,KAAKA,CAACA,CAACA,CAACA,CAACA;oBAC1BA,IAAIA,CAACA,KAAKA,CAACA,MAAMA,CAACA,IAAIA,CAACA,IAAIA,CAACA,KAAKA,EAAEA,IAAIA,MAAMA,CAAOA,KAAKA,EAAEA,IAAIA,CAACA,SAASA,CAACA,CAACA,CAACA;gBAC7EA,CAACA;gBACDA,IAAIA,CAACA,CAACA;oBACLA,IAAIA,CAACA,KAAKA,CAACA,MAAMA,CAACA,IAAIA,CAACA,IAAIA,CAACA,KAAKA,EAAEA,KAAKA,EAAEA,IAAIA,CAACA,SAASA,CAACA,CAACA;gBAC3DA,CAACA;gBACDA,MAAMA,CAACA,eAAeA,CAACA;YACxBA,CACAA;YAAAA,KAAKA,CAACA,CAACA,KAAKA,CAACA,CAACA,CAACA;gBACdA,IAAIA,CAACA,OAAOA,CAACA,KAAKA,CAACA,CAACA;gBACpBA,MAAMA,CAACA,IAAIA,CAACA,SAASA,CAACA;YACvBA,CAACA;QACFA,CAACA;QACFJ,iBAACA;IAADA,CAACA,AA9ED,IA8EC;IAED,iBAAgC,SAAiB;QAChDK,EAAEA,CAACA,CAACA,CAACA,CAACA,SAASA,IAAIA,UAAUA,CAACA,CAACA,CAACA,CAACA;YAChCA,MAAMA,IAAIA,KAAKA,CAACA,kDAAkDA,GAAGA,MAAMA,CAACA,IAAIA,CAACA,UAAUA,CAACA,CAACA,IAAIA,CAACA,QAAQA,CAACA,GAAGA,MAAMA,CAACA,CAACA;QACvHA,CAACA;QAEDA,IAAMA,YAAYA,GAAkBA,UAAUA,GAAQA,EAAEA,IAAUA,EAAEA,KAAmBA;YAAnB,qBAAmB,GAAnB,uBAAmB;YACtF,MAAM,CAAC,IAAI,CAAC,SAAS,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;QAC1C,CAAC,CAACA;QACFA,YAAYA,CAACA,MAAMA,GAAGA,UAA0BA,GAAQA,EAAEA,KAAmBA;YAAnB,qBAAmB,GAAnB,uBAAmB;YAC5E,MAAM,CAAC,IAAI,UAAU,CAAI,SAAS,EAAE,GAAG,EAAE,sBAAe,CAAC,KAAK,CAAC,CAAC,CAAC;QAClE,CAAC,CAACA;QAEFA,MAAMA,CAACA,YAAYA,CAACA;IACrBA,CAACA;IAbD,yBAaC,CAAA","sourcesContent":["import * as crypto from 'crypto';\nimport Promise, { State } from 'dojo-core/Promise';\nimport { ByteBuffer, Codec, utf8 } from 'dojo-core/encoding';\nimport { Data, Key, Signer, SignFunction } from '../../crypto';\nimport { getEncodingName } from './util';\n\n/**\n * A mapping of crypto algorithm names to their node equivalents\n */\nconst ALGORITHMS = {\n\thmac: 'hmac'\n};\n\nconst resolvedPromise = Promise.resolve();\n\n/**\n * Generates a signature for a chunk of data.\n */\nfunction sign(algorithm: string, key: Key, data: Data, codec: Codec): Promise<ByteBuffer> {\n\tconst hashAlgorithm = key.algorithm;\n\tconst hmac = crypto.createHmac(hashAlgorithm, <Buffer> key.data);\n\tconst encoding = getEncodingName(codec);\n\n\t// Node crypto requires the input data to be a string or Buffer, so convert arrays to Buffers\n\tif (Array.isArray(data)) {\n\t\tdata = new Buffer(<number[]> data);\n\t}\n\n\thmac.update(data, encoding);\n\treturn Promise.resolve(hmac.digest());\n}\n\n/**\n * An object that can be used to generate a signature for a stream of data.\n */\nclass NodeSigner<T extends Data> implements Signer<T> {\n\tconstructor(algorithm: string, key: Key, encoding: string) {\n\t\tObject.defineProperty(this, 'signature', {\n\t\t\tvalue: new Promise((resolve, reject) => {\n\t\t\t\tObject.defineProperty(this, '_resolve', { value: resolve });\n\t\t\t\tObject.defineProperty(this, '_reject', { value: reject });\n\t\t\t})\n\t\t});\n\n\t\ttry {\n\t\t\t// Throw a useful error if the key is invalid\n\t\t\tif (typeof key.data !== 'string' && !(key.data instanceof Buffer)) { \n\t\t\t\tthrow new Error('Key data must be a non-null string or buffer');\n\t\t\t}\n\n\t\t\tObject.defineProperty(this, '_sign', {\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: crypto.createHmac(key.algorithm, <Buffer> key.data)\n\t\t\t});\n\t\t\tObject.defineProperty(this, '_encoding', { value: encoding });\n\t\t}\n\t\tcatch (error) {\n\t\t\tthis._reject(error);\n\t\t}\n\t}\n\n\tprivate _sign: crypto.Hmac;\n\tprivate _encoding: string;\n\tprivate _resolve: (value: any) => void;\n\tprivate _reject: (reason: Error) => void;\n\n\tsignature: Promise<ByteBuffer>;\n\n\tabort(reason?: Error): Promise<any> {\n\t\tif (this.signature.state !== State.Pending) {\n\t\t\treturn this.signature;\n\t\t}\n\n\t\t// Release the reference to the Hmac/Signer instance and reject the signature\n\t\tObject.defineProperty(this, '_sign', { value: undefined });\n\t\tthis._reject(reason);\n\t\treturn resolvedPromise;\n\t}\n\n\tclose(): Promise<any> {\n\t\tif (this.signature.state !== State.Pending) {\n\t\t\treturn this.signature;\n\t\t}\n\n\t\tconst result = (<crypto.Hmac> this._sign).digest();\n\t\t// Release the reference to the Hmac/Signer instance\n\t\tObject.defineProperty(this, '_sign', { value: undefined });\n\t\tthis._resolve(result);\n\t\treturn resolvedPromise;\n\t}\n\n\twrite(chunk: T): Promise<any> {\n\t\tif (this.signature.state !== State.Pending) {\n\t\t\treturn this.signature;\n\t\t}\n\n\t\tlet _chunk: T | Buffer = chunk;\n\t\t// Node can't work with Arrays, so convert them to Buffers\n\t\t// The node typing for Sign#update is incorrect -- it shares the same signature as Hash#update\n\t\ttry {\n\t\t\tif (Array.isArray(chunk)) {\n\t\t\t\tthis._sign.update.call(this._sign, new Buffer(<any> chunk, this._encoding));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis._sign.update.call(this._sign, chunk, this._encoding);\n\t\t\t}\n\t\t\treturn resolvedPromise;\n\t\t}\n\t\tcatch (error) {\n\t\t\tthis._reject(error);\n\t\t\treturn this.signature;\n\t\t}\n\t}\n}\n\nexport default function getSign(algorithm: string): SignFunction {\n\tif (!(algorithm in ALGORITHMS)) {\n\t\tthrow new Error('invalid algorithm; available algorithms are [ \\'' + Object.keys(ALGORITHMS).join('\\', \\'') + '\\' ]');\n\t}\n\n\tconst signFunction = <SignFunction> function (key: Key, data: Data, codec: Codec = utf8): Promise<ByteBuffer> {\n\t\treturn sign(algorithm, key, data, codec);\n\t};\n\tsignFunction.create = function<T extends Data> (key: Key, codec: Codec = utf8): Signer<T> {\n\t\treturn new NodeSigner<T>(algorithm, key, getEncodingName(codec));\n\t};\n\n\treturn signFunction;\n}\n"]}