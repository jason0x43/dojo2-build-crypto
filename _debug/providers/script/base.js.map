{"version":3,"file":"base.js","sourceRoot":"","sources":["providers/script/base.ts"],"names":["addWords","Endian","bytesToWords","wordsToBytes"],"mappings":"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","sourcesContent":["/**\n * Notation:\n *   - A \"word\" is a 32-bit interger\n */\nimport { ByteBuffer } from 'dojo-core/encoding';\n\n/**\n * A script hash function\n */\nexport interface ScriptHash {\n\t(data: ByteBuffer): ByteBuffer;\n\tblockSize: number;\n}\n\n/**\n * A general math function\n */\nexport interface MathFunction {\n\t(...inputs: number[]): number\n}\n\n/**\n * Add a list of words, with rollover\n */\nexport function addWords(...words: number[]): number {\n\tconst numWords = words.length;\n\tlet sum = words[0];\n\tfor (let i = 1; i < numWords; i++) {\n\t\tconst a = sum;\n\t\tconst b = words[i];\n\t\tconst low = (a & 0xFFFF) + (b & 0xFFFF);\n\t\tconst high = (a >> 16) + (b >> 16) + (low >> 16);\n\t\tsum = (high << 16) | (low & 0xFFFF);\n\t}\n\treturn sum;\n}\n\n/**\n * Specify the endian-ness of a integer values\n */\nexport enum Endian {\n\tLittle = 0,\n\tBig = 1\n}\n\n/**\n * Convert an array of bytes to an array of 32-bit words. Words are assumed to be encoded in little-endian format (low\n * bytes are at lower indices).\n */\nexport function bytesToWords(bytes: ByteBuffer, endian: Endian = Endian.Big): number[] {\n\tconst numWords = Math.ceil(bytes.length / 4);\n\tconst words = new Array(numWords);\n\n\tconst s0 =  0 + 24 * endian;\n\tconst s1 =  8 +  8 * endian;\n\tconst s2 = 16 -  8 * endian;\n\tconst s3 = 24 - 24 * endian;\n\n\tfor (let i = 0; i < numWords; i++) {\n\t\tconst j = 4 * i;\n\t\twords[i] = \n\t\t\t(bytes[j]     << s0) |\n\t\t\t(bytes[j + 1] << s1) |\n\t\t\t(bytes[j + 2] << s2) |\n\t\t\t(bytes[j + 3] << s3);\n\t}\n\treturn words;\n}\n\n/**\n * Convert an array of 32-bit words to an array of bytes. Words are encoded in big-endian format (high bytes are at\n * lower indices).\n */\nexport function wordsToBytes(words: number[], endian: Endian = Endian.Big): number[] {\n\tconst numWords = words.length;\n\tconst bytes = new Array(numWords * 4);\n\n\tconst s0 =  0 + 24 * endian;\n\tconst s1 =  8 +  8 * endian;\n\tconst s2 = 16 -  8 * endian;\n\tconst s3 = 24 - 24 * endian;\n\n\tfor (let i = 0; i < numWords; i++) {\n\t\tconst word = words[i];\n\t\tconst j = 4 * i;\n\t\tbytes[j]     = (word >> s0) & 0x0FF;\n\t\tbytes[j + 1] = (word >> s1) & 0x0FF;\n\t\tbytes[j + 2] = (word >> s2) & 0x0FF;\n\t\tbytes[j + 3] = (word >> s3) & 0x0FF;\n\t}\n\treturn bytes;\n}\n"]}